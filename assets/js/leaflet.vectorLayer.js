// Generated by CoffeeScript 1.6.3
(function() {
  L.VectorLayer = {
    author: "Helmuth Duarte Saatkamp <helmuthdu@gmail.com>"
  };

  L.VectorLayer.Layer = L.Class.extend({
    options: {
      scaleRange: null,
      map: null,
      cluster: false,
      uniqueField: null,
      visibleAtScale: true,
      dynamic: false,
      autoUpdate: false,
      autoUpdateInterval: null,
      popupTemplate: null,
      popupOptions: {},
      singlePopup: false,
      symbology: null,
      showAll: false,
      focus: false,
      above: false
    },
    initialize: function(options) {
      return L.Util.setOptions(this, options);
    },
    setMap: function(map) {
      var sr, z;
      if (map && this.options.map) {
        return;
      }
      if (map) {
        this.options.map = map;
        if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
          z = this.options.map.getZoom();
          sr = this.options.scaleRange;
          this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
        }
        return this._show();
      } else if (this.options.map) {
        this._hide();
        return this.options.map = map;
      }
    },
    getMap: function() {
      return this.options.map;
    },
    setOptions: function(options) {
      return L.Util.setOptions(this, options);
    },
    redraw: function() {
      this._hide();
      return this._show();
    },
    _show: function() {
      var _this = this;
      this._addIdleListener();
      if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
        this._addZoomChangeListener();
      }
      if (this.options.visibleAtScale) {
        if (this.options.autoUpdate && this.options.autoUpdateInterval) {
          this._autoUpdateInterval = setInterval(function() {
            return _this._getFeatures();
          }, this.options.autoUpdateInterval);
        }
        return this.options.map.fire("moveend").fire("zoomend");
      }
    },
    _hide: function() {
      if (this._idleListener) {
        this.options.map.off("moveend", this._idleListener);
      }
      if (this._zoomChangeListener) {
        this.options.map.off("zoomend", this._zoomChangeListener);
      }
      if (this._autoUpdateInterval) {
        clearInterval(this._autoUpdateInterval);
      }
      this._lastQueriedBounds = null;
      if (this._gotAll) {
        this._gotAll = false;
      }
      return this._clearFeatures();
    },
    _hideVectors: function() {
      return this.options.map.removeLayer(this.layer);
    },
    _showVectors: function() {
      return this.layer.addTo(this.options.map);
    },
    _clearFeatures: function() {
      this._vectors = [];
      return this.layer.clearLayers();
    },
    _addZoomChangeListener: function() {
      this._zoomChangeListener = this._zoomChangeListenerTemplate();
      return this.options.map.on("zoomend", this._zoomChangeListener, this);
    },
    _zoomChangeListenerTemplate: function() {
      var _this = this;
      return function() {
        return _this._checkLayerVisibility();
      };
    },
    _idleListenerTemplate: function() {
      var _this = this;
      return function() {
        if (_this.options.visibleAtScale) {
          if (_this.options.showAll) {
            if (!_this._gotAll) {
              _this._getFeatures();
              return _this._gotAll = true;
            }
          } else {
            _this._hide();
            return _this._getFeatures();
          }
        }
      };
    },
    _addIdleListener: function() {
      this._idleListener = this._idleListenerTemplate();
      return this.options.map.on("moveend", this._idleListener, this);
    },
    _checkLayerVisibility: function() {
      var sr, visibilityBefore, z;
      visibilityBefore = this.options.visibleAtScale;
      z = this.options.map.getZoom();
      sr = this.options.scaleRange;
      this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
      if (visibilityBefore !== this.options.visibleAtScale) {
        this[(this.options.visibleAtScale ? "_showVectors" : "_hideVectors")]();
      }
      if (visibilityBefore && !this.options.visibleAtScale && this._autoUpdateInterval) {
        return clearInterval(this._autoUpdateInterval);
      } else if (!visibilityBefore && this.options.autoUpdate && this.options.autoUpdateInterval) {
        return this._autoUpdateInterval = setInterval(function() {
          return this._getFeatures();
        }, this.options.autoUpdateInterval);
      }
    },
    _setPopupContent: function(feature) {
      var atts, popupContent, previousContent, prop, re;
      previousContent = feature.popupContent;
      atts = feature.properties;
      popupContent = void 0;
      if (typeof this.options.popupTemplate === "string") {
        popupContent = this.options.popupTemplate;
        for (prop in atts) {
          re = new RegExp("{" + prop + "}", "g");
          popupContent = popupContent.replace(re, atts[prop]);
        }
      } else if (typeof this.options.popupTemplate === "function") {
        popupContent = this.options.popupTemplate(atts);
      } else {
        return;
      }
      feature.popupContent = popupContent;
      if (feature.popup) {
        if (feature.popupContent !== previousContent) {
          return feature.popup.setContent(feature.popupContent);
        }
      } else if (this.popup && this.popup.associatedFeature === feature) {
        if (feature.popupContent !== previousContent) {
          return this.popup.setContent(feature.popupContent);
        }
      }
    },
    _showPopup: function(feature, event) {
      var isLineOrPolygon, ownsPopup;
      isLineOrPolygon = event.latlng;
      if (!isLineOrPolygon) {
        L.Util.extend(this.options.popupOptions, {
          offset: event.target.options.icon.options.popupAnchor
        });
      }
      ownsPopup = void 0;
      if (!this.options.singlePopup) {
        feature.popup = new L.Popup(this.options.popupOptions, feature.vector);
        ownsPopup = feature;
      } else {
        if (this.popup) {
          this.options.map.removeLayer(this.popup);
          this.popup = null;
        }
        this.popup = new L.Popup(this.options.popupOptions, feature.vector);
        this.popup.associatedFeature = feature;
        ownsPopup = this;
      }
      ownsPopup.popup.setLatLng((isLineOrPolygon ? event.latlng : event.target.getLatLng()));
      ownsPopup.popup.setContent(feature.popupContent);
      return this.options.map.addLayer(ownsPopup.popup);
    },
    _fireClickEvent: function(feature, event) {
      return this.options.clickEvent(feature, event);
    },
    _fireMouseoverEvent: function(feature, event) {
      return this.options.mouseoverEvent(feature, event);
    },
    _fireMouseoutEvent: function(feature, event) {
      return this.options.mouseoutEvent(feature, event);
    },
    _getFeatureVectorOptions: function(feature) {
      var att, atts, i, key, prop, re, vectorStyle, _i, _j, _ref, _ref1;
      vectorStyle = {};
      atts = feature.properties;
      if (this.options.symbology) {
        switch (this.options.symbology.type) {
          case "single":
            for (key in this.options.symbology.vectorStyle) {
              vectorStyle[key] = this.options.symbology.vectorStyle[key];
              if (vectorStyle.title) {
                for (prop in atts) {
                  re = new RegExp("{" + prop + "}", "g");
                  vectorStyle.title = vectorStyle.title.replace(re, atts[prop]);
                }
              }
            }
            break;
          case "unique":
            att = this.options.symbology.property;
            for (i = _i = 0, _ref = this.options.symbology.values.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              if (atts[att] === this.options.symbology.values[i].value) {
                for (key in this.options.symbology.values[i].vectorStyle) {
                  vectorStyle[key] = this.options.symbology.values[i].vectorStyle[key];
                  if (vectorStyle.title) {
                    for (prop in atts) {
                      re = new RegExp("{" + prop + "}", "g");
                      vectorStyle.title = vectorStyle.title.replace(re, atts[prop]);
                    }
                  }
                }
              }
            }
            break;
          case "range":
            att = this.options.symbology.property;
            for (i = _j = 0, _ref1 = this.options.symbology.ranges.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              if (atts[att] >= this.options.symbology.ranges[i].range[0] && atts[att] <= this.options.symbology.ranges[i].range[1]) {
                for (key in this.options.symbology.ranges[i].vectorStyle) {
                  vectorStyle[key] = this.options.symbology.ranges[i].vectorStyle[key];
                  if (vectorStyle.title) {
                    for (prop in atts) {
                      re = new RegExp("{" + prop + "}", "g");
                      vectorStyle.title = vectorStyle.title.replace(re, atts[prop]);
                    }
                  }
                }
              }
            }
        }
      }
      return vectorStyle;
    },
    _getPropertiesChanged: function(oldAtts, newAtts) {
      var changed, key;
      changed = false;
      for (key in oldAtts) {
        if (oldAtts[key] !== newAtts[key]) {
          changed = true;
        }
      }
      return changed;
    },
    _getPropertyChanged: function(oldAtts, newAtts, property) {
      return oldAtts[property] !== newAtts[property];
    },
    _getGeometryChanged: function(oldGeom, newGeom) {
      var changed;
      changed = false;
      if (oldGeom.coordinates[0] !== newGeom.coordinates[0] || oldGeom.coordinates[1] !== newGeom.coordinates[1]) {
        changed = true;
      }
      return changed;
    },
    _makeJsonpRequest: function(url) {
      var _this = this;
      return $.ajax({
        url: url,
        type: "GET",
        dataType: "jsonp",
        crossDomain: true,
        success: function(data) {
          return _this._processRequest(data);
        },
        error: function(xhr, status, error) {
          return console.log("Failed URL request: " + error);
        }
      });
    },
    _processRequest: function(json) {
      var data, i, prop, _i, _ref;
      data = {};
      data.features = [];
      data.total = json.length;
      data.type = "FeatureCollection";
      for (i = _i = 0, _ref = json.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        data.features[i] = {};
        data.features[i].type = "Feature";
        data.features[i].properties = {};
        for (prop in json[i]) {
          if (prop === "geojson") {
            data.features[i].geometry = JSON.parse(json[i].geojson);
          } else {
            if (prop !== "properties") {
              data.features[i].properties[prop] = json[i][prop];
            }
          }
        }
      }
      json = null;
      return this._processFeatures(data);
    },
    _processFeatures: function(data) {
      var bounds, feature, geometry, geometryOptions, i, j, k, me, onMap, propertiesChanged, symbologyPropertyChanged, vector_or_vectors, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      if (!this.options.map) {
        return;
      }
      bounds = this.options.map.getBounds();
      if (this._lastQueriedBounds && this._lastQueriedBounds.equals(bounds) && !this.options.autoUpdate) {
        return;
      }
      this._lastQueriedBounds = bounds;
      this.layer.addTo(this.options.map);
      if (data && data.features && data.features.length) {
        for (i = _i = 0, _ref = data.features.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          onMap = false;
          if (this.options.uniqueField) {
            for (j = _j = 0, _ref1 = this._vectors.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              if (data.features[i].properties[this.options.uniqueField] === this._vectors[j].properties[this.options.uniqueField]) {
                onMap = true;
                if (this.options.dynamic) {
                  if (this._getGeometryChanged(this._vectors[j].geometry, data.features[i].geometry)) {
                    if (!isNaN(data.features[i].geometry.coordinates[0]) && !isNaN(data.features[i].geometry.coordinates[1])) {
                      this._vectors[j].geometry = data.features[i].geometry;
                      this._vectors[j].vector.setLatLng(new L.LatLng(this._vectors[j].geometry.coordinates[1], this._vectors[j].geometry.coordinates[0]));
                    }
                  }
                  propertiesChanged = this._getPropertiesChanged(this._vectors[j].properties, data.features[i].properties);
                  if (propertiesChanged) {
                    symbologyPropertyChanged = this._getPropertyChanged(this._vectors[j].properties, data.features[i].properties, this.options.symbology.property);
                    this._vectors[j].properties = data.features[i].properties;
                    if (this.options.popupTemplate) {
                      this._setPopupContent(this._vectors[j]);
                    }
                    if (this.options.symbology && this.options.symbology.type !== "single" && symbologyPropertyChanged) {
                      if (this._vectors[j].vectors) {
                        for (k = _k = 0, _ref2 = this._vectors[j].vectors.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                          if (this._vectors[j].vectors[k].setStyle) {
                            this._vectors[j].vectors[k].setStyle(this._getFeatureVectorOptions(this._vectors[j]));
                          } else {
                            if (this._vectors[j].vectors[k].setIcon) {
                              this._vectors[j].vectors[k].setIcon(this._getFeatureVectorOptions(this._vectors[j]).icon);
                            }
                          }
                        }
                      } else if (this._vectors[j].vector) {
                        if (this._vectors[j].vector.setStyle) {
                          this._vectors[j].vector.setStyle(this._getFeatureVectorOptions(this._vectors[j]));
                        } else {
                          if (this._vectors[j].vector.setIcon) {
                            this._vectors[j].vector.setIcon(this._getFeatureVectorOptions(this._vectors[j]).icon);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (!onMap || !this.options.uniqueField) {
            geometry = data.features[i].geometry;
            geometryOptions = this._getFeatureVectorOptions(data.features[i]);
            vector_or_vectors = this._geoJsonGeometryToLeaflet(geometry, geometryOptions);
            data.features[i][(vector_or_vectors instanceof Array ? "vectors" : "vector")] = vector_or_vectors;
            this._vectors.push(data.features[i]);
            if (this._vectors[i].vector) {
              this.layer.addLayer(this._vectors[i].vector);
            } else if (this._vectors[i].vectors && this._vectors[i].vectors.length) {
              for (k = _l = 0, _ref3 = this._vectors[i].vectors.length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; k = 0 <= _ref3 ? ++_l : --_l) {
                this.layer.addLayer(this._vectors[i].vectors[k]);
              }
            }
            if (this.options.popupTemplate) {
              me = this;
              feature = data.features[i];
              this._setPopupContent(feature);
              (function(feature) {
                var _m, _ref4, _results;
                if (feature.vector) {
                  return feature.vector.on("click", function(event) {
                    return me._showPopup(feature, event);
                  });
                } else if (feature.vectors) {
                  _results = [];
                  for (k = _m = 0, _ref4 = feature.vectors.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; k = 0 <= _ref4 ? ++_m : --_m) {
                    _results.push(feature.vectors[k].on("click", function(event) {
                      return me._showPopup(feature, event);
                    }));
                  }
                  return _results;
                }
              })(feature);
            }
            if (this.options.clickEvent) {
              me = this;
              feature = data.features[i];
              (function(feature) {
                var _m, _ref4, _results;
                if (feature.vector) {
                  return feature.vector.on("click", function(event) {
                    return me._fireClickEvent(feature, event);
                  });
                } else if (feature.vectors) {
                  _results = [];
                  for (k = _m = 0, _ref4 = feature.vectors.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; k = 0 <= _ref4 ? ++_m : --_m) {
                    _results.push(feature.vectors[k].on("click", function(event) {
                      return me._fireClickEvent(feature, event);
                    }));
                  }
                  return _results;
                }
              })(feature);
            }
            if (this.options.mouseoverEvent) {
              me = this;
              feature = data.features[i];
              (function(feature) {
                var _m, _ref4, _results;
                if (feature.vector) {
                  return feature.vector.on("mouseover", function(event) {
                    return me._fireMouseoverEvent(feature, event);
                  });
                } else if (feature.vectors) {
                  _results = [];
                  for (k = _m = 0, _ref4 = feature.vectors.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; k = 0 <= _ref4 ? ++_m : --_m) {
                    _results.push(feature.vectors[k].on("mouseover", function(event) {
                      return me._fireMouseoverEvent(feature, event);
                    }));
                  }
                  return _results;
                }
              })(feature);
            }
            if (this.options.mouseoutEvent) {
              me = this;
              feature = data.features[i];
              (function(feature) {
                var _m, _ref4, _results;
                if (feature.vector) {
                  return feature.vector.on("mouseout", function(event) {
                    return me._fireMouseoutEvent(feature, event);
                  });
                } else if (feature.vectors) {
                  _results = [];
                  for (k = _m = 0, _ref4 = feature.vectors.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; k = 0 <= _ref4 ? ++_m : --_m) {
                    _results.push(feature.vectors[k].on("mouseout", function(event) {
                      return me._fireMouseoutEvent(feature, event);
                    }));
                  }
                  return _results;
                }
              })(feature);
            }
          }
        }
      }
      if (this.options.above) {
        this.layer.eachLayer(function(layer) {
          if (layer.setZIndexOffset) {
            return layer.setZIndexOffset(1000);
          }
        });
      }
      if (this.options.focus) {
        this.options.map.fitBounds(this.layer.getBounds());
      }
      return data = null;
    }
  });

  L.VectorLayer.GeoJSONLayer = L.VectorLayer.Layer.extend({
    _geoJsonGeometryToLeaflet: function(geometry, opts) {
      var i, j, k, latlngs, latlngss, vector, vectors, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      vector = void 0;
      vectors = void 0;
      switch (geometry.type) {
        case "Point":
          if (opts.circleMarker) {
            vector = new L.CircleMarker(new L.LatLng(geometry.coordinates[1], geometry.coordinates[0]), opts);
          } else {
            vector = new L.Marker(new L.LatLng(geometry.coordinates[1], geometry.coordinates[0]), opts);
          }
          break;
        case "MultiPoint":
          vectors = [];
          for (i = _i = 0, _ref = geometry.coordinates.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            vectors.push(new L.Marker(new L.LatLng(geometry.coordinates[i][1], geometry.coordinates[i][0]), opts));
          }
          break;
        case "LineString":
          latlngs = [];
          for (i = _j = 0, _ref1 = geometry.coordinates.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            latlngs.push(new L.LatLng(geometry.coordinates[i][1], geometry.coordinates[i][0]));
          }
          vector = new L.Polyline(latlngs, opts);
          break;
        case "MultiLineString":
          vectors = [];
          for (i = _k = 0, _ref2 = geometry.coordinates.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            latlngs = [];
            for (j = _l = 0, _ref3 = geometry.coordinates[i].length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
              latlngs.push(new L.LatLng(geometry.coordinates[i][j][1], geometry.coordinates[i][j][0]));
            }
            vectors.push(new L.Polyline(latlngs, opts));
          }
          break;
        case "Polygon":
          latlngss = [];
          for (i = _m = 0, _ref4 = geometry.coordinates.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
            latlngs = [];
            for (j = _n = 0, _ref5 = geometry.coordinates[i].length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
              latlngs.push(new L.LatLng(geometry.coordinates[i][j][1], geometry.coordinates[i][j][0]));
            }
            latlngss.push(latlngs);
          }
          vector = new L.Polygon(latlngss, opts);
          break;
        case "MultiPolygon":
          vectors = [];
          for (i = _o = 0, _ref6 = geometry.coordinates.length; 0 <= _ref6 ? _o < _ref6 : _o > _ref6; i = 0 <= _ref6 ? ++_o : --_o) {
            latlngss = [];
            for (j = _p = 0, _ref7 = geometry.coordinates[i].length; 0 <= _ref7 ? _p < _ref7 : _p > _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
              latlngs = [];
              for (k = _q = 0, _ref8 = geometry.coordinates[i][j].length; 0 <= _ref8 ? _q < _ref8 : _q > _ref8; k = 0 <= _ref8 ? ++_q : --_q) {
                latlngs.push(new L.LatLng(geometry.coordinates[i][j][k][1], geometry.coordinates[i][j][k][0]));
              }
              latlngss.push(latlngs);
            }
            vectors.push(new L.Polygon(latlngss, opts));
          }
          break;
        case "GeometryCollection":
          vectors = [];
          for (i = _r = 0, _ref9 = geometry.coordinates.length; 0 <= _ref9 ? _r < _ref9 : _r > _ref9; i = 0 <= _ref9 ? ++_r : --_r) {
            vectors.push(this._geoJsonGeometryToLeaflet(geometry.geometries[i], opts));
          }
      }
      return vector || vectors;
    }
  });

  L.VectorLayer.Postgis = L.VectorLayer.GeoJSONLayer.extend({
    initialize: function(options) {
      var i, sr, z, _i, _ref;
      for (i = _i = 0, _ref = this._requiredParams.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!options[this._requiredParams[i]]) {
          throw new Error("No \"" + this._requiredParams[i] + "\" parameter found.");
        }
      }
      if (options.url.substr(options.url.length - 1, 1) !== "/") {
        options.url += "/";
      }
      L.VectorLayer.Layer.prototype.initialize.call(this, options);
      this._globalPointer = "Postgis_" + this.options.geotable + "_" + this.options.geomFieldName;
      window[this._globalPointer] = this;
      this._vectors = [];
      if (this.options.cluster) {
        this.layer = new L.MarkerClusterGroup();
      } else {
        this.layer = new L.featureGroup();
      }
      if (this.options.map) {
        if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
          z = this.options.map.getZoom();
          sr = this.options.scaleRange;
          this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
        }
        return this._show();
      }
    },
    options: {
      geotable: null,
      srid: null,
      geomFieldName: "the_geom",
      fields: null,
      where: null,
      limit: 5000,
      uniqueField: null
    },
    _requiredParams: ["url", "geotable"],
    _getFeatures: function() {
      var bounds, fields, ne, sw, url, where;
      where = (this.options.where ? "&parameters=" + encodeURIComponent(this.options.where) : "");
      if (!this.options.showAll) {
        bounds = this.options.map.getBounds();
        sw = bounds.getSouthWest();
        ne = bounds.getNorthEast();
        where += (where.length ? " AND " : "");
        if (this.options.srid) {
          where += encodeURIComponent("st_setsrid(" + this.options.geomFieldName + "," + this.options.srid + ") && st_setsrid(st_makebox2d(st_point(" + sw.lng + "," + sw.lat + "),st_point(" + ne.lng + "," + ne.lat + "))," + this.options.srid + ")");
        } else {
          where += encodeURIComponent("" + this.options.geomFieldName + " && st_setsrid(st_makebox2d(st_point(" + sw.lng + "," + sw.lat + "),st_point(" + ne.lng + "," + ne.lat + "))");
        }
      }
      fields = (this.options.fields ? this.options.fields : "*") + ", st_asgeojson(" + this.options.geomFieldName + "" + (this.options.geomPrecision ? "," + this.options.geomPrecision : "") + ") as geojson";
      url = this.options.url + "v1/ws_geo_attributequery.php" + "?table=" + this.options.geotable + "&fields=" + encodeURIComponent(fields) + where + "&limit=" + this.options.limit;
      return this._makeJsonpRequest(url);
    }
  });

  L.VectorLayer.Geoserver = L.VectorLayer.GeoJSONLayer.extend({
    initialize: function(options) {
      var i, len, sr, z;
      i = 0;
      len = this._requiredParams.length;
      while (i < len) {
        if (!options[this._requiredParams[i]]) {
          throw new Error("No \"" + this._requiredParams[i] + "\" parameter found.");
        }
        i++;
      }
      lvector.Layer.prototype.initialize.call(this, options);
      this._globalPointer = "Geoserver_" + Math.floor(Math.random() * 100000);
      window[this._globalPointer] = this;
      this._vectors = [];
      if (this.options.map) {
        if (this.options.scaleRange && this.options.scaleRange instanceof Array && this.options.scaleRange.length === 2) {
          z = this.options.map.getZoom();
          sr = this.options.scaleRange();
          this.options.visibleAtScale = z >= sr[0] && z <= sr[1];
        }
        return this._show();
      }
    },
    options: {
      baseUrl: null,
      typeName: null,
      uniqueField: null
    },
    _requiredParams: ["baseUrl", "typeName", "uniqueField"],
    _getFeatures: function() {
      var url;
      url = this.options.baseUrl.replace(/\?$/, "") + "?service=WFS&version=1.1.0&request=GetFeature&typeName=" + this.options.typeName + "&outputFormat=json&format_options=callback:" + this._globalPointer + "._processRequest";
      if (!this.options.showAll) {
        url += "&bbox=" + this.options.map.getBounds().toBBoxString();
      }
      return this._makeJsonpRequest(url);
    }
  });

}).call(this);
